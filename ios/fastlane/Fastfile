def app_identifiers
  [
    "io.bluewallet.bluewallet", 
    "io.bluewallet.bluewallet.watch", 
    "io.bluewallet.bluewallet.watch.extension", 
    "io.bluewallet.bluewallet.Stickers", 
    "io.bluewallet.bluewallet.MarketWidget"
  ]
end

def setup_provisioning_profiles(platform)
  UI.message("Setting up provisioning profiles for #{platform}...")
  
  app_identifiers.each do |app_identifier|
    match(
      type: "development",
      platform: platform,
      app_identifier: app_identifier,
      readonly: false,
      force_for_new_devices: true
    )

    match(
      type: "appstore",
      platform: platform,
      app_identifier: app_identifier,
      readonly: false
    )
  end

  UI.message("#{platform.capitalize} provisioning profiles set up successfully.")
end

def build_app_for_platform(platform)
  UI.message("Building the #{platform.capitalize} application...")
  
  setup_provisioning_profiles(platform)
  
  build_app(
    scheme: "BlueWallet",
    workspace: "BlueWallet.xcworkspace",
    configuration: "Release",
    sdk: platform == "catalyst" ? "macosx" : nil,
    export_method: "app-store",
    include_bitcode: false,
    export_options: {
      signingStyle: "manual",
      provisioningProfiles: {
        'io.bluewallet.bluewallet' => 'match AppStore io.bluewallet.bluewallet',
        'io.bluewallet.bluewallet.watch' => 'match AppStore io.bluewallet.bluewallet.watch',
        'io.bluewallet.bluewallet.watch.extension' => 'match AppStore io.bluewallet.bluewallet.watch.extension',
        'io.bluewallet.bluewallet.Stickers' => 'match AppStore io.bluewallet.bluewallet.Stickers',
        'io.bluewallet.bluewallet.MarketWidget' => 'match AppStore io.bluewallet.bluewallet.MarketWidget'
      }
    },
    output_directory: "./build",
    output_name: "BlueWallet.#{ENV['PROJECT_VERSION']}(#{ENV['NEW_BUILD_NUMBER']}).#{platform == "catalyst" ? "app" : "ipa"}",
    buildlog_path: "./build_logs"
  )
end

def notarize_app(app_path)
  UI.message("Notarizing the app...")

  notarize(
    username: ENV["AC_USERNAME"],
    app_identifier: ENV["AC_APP_ID"],
    primary_bundle_id: "io.bluewallet.bluewallet",
    app_path: app_path,
    developer_id: ENV["AC_DEVELOPER_ID"],
    team_id: ENV["ITC_TEAM_ID"],
    api_key_path: "appstore_api_key.json"
  )

  UI.message("App notarization complete.")
end

def create_dmg(app_name)
  UI.message("Creating DMG for #{app_name}...")

  dmg_path = "./build/#{app_name}.dmg"
  sh("hdiutil create -volname '#{app_name}' -srcfolder './build/#{app_name}.app' -ov -format UDZO '#{dmg_path}'")
  
  UI.message("DMG created at #{dmg_path}.")
  dmg_path
end

platform :ios do

  before_all do |lane, options|
    UI.message("Setting up for all lanes...")
    UI.message("Discarding all untracked changes before running any lane...")
    sh("git clean -fd")
    sh("git checkout -- .")
  end

  desc "Register new devices from a file"
  lane :register_devices_from_txt do
    UI.message("Registering new devices from file...")
    csv_path = "../../devices.txt" # Update this with the actual path to your file

    register_devices(devices_file: csv_path)

    UI.message("Devices registered successfully.")
    setup_provisioning_profiles("ios")
  end  

  desc "Create a temporary keychain"
  lane :create_temp_keychain do
    UI.message("Creating a temporary keychain...")
    create_keychain(
      name: "temp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: true
    )
    UI.message("Temporary keychain created successfully.")
  end

  desc "Clear derived data"
  lane :clear_derived_data_lane do
    UI.message("Clearing derived data...")
    clear_derived_data
  end

  desc "Increment build number"
  lane :increment_build_number_lane do
    UI.message("Incrementing build number to current timestamp...")
    increment_build_number(
      xcodeproj: "BlueWallet.xcodeproj", 
      build_number: ENV["NEW_BUILD_NUMBER"]
    )
    UI.message("Build number set to: #{ENV['NEW_BUILD_NUMBER']}")
  end

  desc "Install CocoaPods dependencies"
  lane :install_pods do
    UI.message("Installing CocoaPods dependencies...")
    cocoapods
  end

  desc "Build the iOS app"
  lane :build_app_lane do
    build_app_for_platform("ios")
  end

  desc "Build the Mac Catalyst app"
  lane :build_catalyst_app do
    app_path = build_app_for_platform("catalyst")
    notarize_app(app_path)
    dmg_path = create_dmg("BlueWallet")
    Actions.lane_context[SharedValues::DMG_PATH] = dmg_path
  end

  desc "Upload to TestFlight without Processing Wait"
  lane :upload_to_testflight_lane do
    attempts = 0
    max_attempts = 3
    begin
      UI.message("Uploading to TestFlight without processing wait...")
      changelog = ENV["LATEST_COMMIT_MESSAGE"]

      upload_to_testflight(
        api_key_path: "appstore_api_key.json",
        ipa: "./build/BlueWallet.#{ENV['PROJECT_VERSION']}(#{ENV['NEW_BUILD_NUMBER']}).ipa",
        skip_waiting_for_build_processing: true, # Do not wait for processing
        changelog: changelog
      )
    rescue => exception
      attempts += 1
      if attempts <= max_attempts
        wait_time = 180 # 3 minutes in seconds
        UI.message("Attempt ##{attempts} failed with error: #{exception.message}. Waiting #{wait_time} seconds before trying again...")
        sleep(wait_time)
        retry
      else
        UI.error("Failed after #{max_attempts} attempts. Error: #{exception.message}")
        raise exception
      end
    end
  end

  desc "Deploy to TestFlight"
  lane :deploy do
    UI.message("Starting build process...")

    update_wwdr_certificate
    setup_app_store_connect_api_key
    clear_derived_data_lane
    increment_build_number_lane

    unless File.directory?("Pods")
      install_pods
    end

    build_app_lane
    upload_to_testflight_lane

    delete_keychain(name: "temp_keychain")

    last_commit = last_git_commit
    already_built_flag = ".already_built_#{last_commit[:sha]}"
    File.write(already_built_flag, Time.now.to_s)
  end

  desc "Update 'What's New' section in App Store Connect for all localizations"
  lane :update_release_notes do
    release_notes_path = "../../release-notes.txt"
    
    unless File.exist?(release_notes_path)
      UI.error("Release notes file does not exist at path: #{release_notes_path}")
      next
    end

    release_notes_text = File.read(release_notes_path)
    UI.message("Release Notes Content:\n#{release_notes_text}")

    app_version = get_version_number
    UI.message("Version being updated: #{app_version}")

    localized_release_notes = {
      'en-US' => release_notes_text,
      'ar-SA' => release_notes_text,
      'zh-Hans' => release_notes_text,
      'da' => release_notes_text,
      'nl-NL' => release_notes_text,
      'fi' => release_notes_text,
      'fr-FR' => release_notes_text,
      'de-DE' => release_notes_text,
      'he' => release_notes_text,
      'hu' => release_notes_text,
      'it' => release_notes_text,
      'pt-BR' => release_notes_text,
      'pt-PT' => release_notes_text,
      'ro' => release_notes_text,
      'ru' => release_notes_text,
      'es-MX' => release_notes_text,
      'es-ES' => release_notes_text,
      'sv' => release_notes_text,
    }

    localized_release_notes.each do |locale, notes|
      UI.message("Setting release notes for #{locale}:\n#{notes}\n")
    end

    deliver(
      app_identifier: app_identifiers.first,
      app_version: app_version,
      skip_metadata: true,
      skip_screenshots: true,
      skip_binary_upload: true,
      force: true,
      release_notes: localized_release_notes,
      submit_for_review: false,
      automatic_release: false
    )
  end

end
