# Define app identifiers once for reuse across lanes
def app_identifiers
  [
    "io.bluewallet.bluewallet",
    "io.bluewallet.bluewallet.watch",
    "io.bluewallet.bluewallet.watch.extension",
    "io.bluewallet.bluewallet.Stickers",
    "io.bluewallet.bluewallet.MarketWidget"
  ]
end

default_platform(:android)
project_root = File.expand_path("..", __dir__)

# ===========================
#       Helper Methods
# ===========================

desc "Update Apple Worldwide Developer Relations certificate"
lane :update_wwdr_certificate do
  UI.message("Updating Apple WWDR certificate...")
  
  sh("curl -sL https://developer.apple.com/certificationauthority/AppleWWDRCA.cer -o /tmp/AppleWWDRCA.cer")
  sh("security import /tmp/AppleWWDRCA.cer -k /Library/Keychains/System.keychain -T /usr/bin/codesign")
  
  UI.message("Apple WWDR certificate updated successfully")
rescue => e
  UI.important("Failed to update WWDR certificate: #{e.message}")
  UI.important("This is not critical, continuing with the process...")
end

desc "Setup App Store Connect API Key"
lane :setup_app_store_connect_api_key do
  UI.message("Setting up App Store Connect API Key...")
  
  # Check if the key file exists
  api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH'] || "./appstore_api_key.p8"
  api_key_content = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
  
  if api_key_content && !File.exist?(api_key_path)
    UI.message("Creating API key file from content...")
    File.write(api_key_path, api_key_content)
  end
  
  unless File.exist?(api_key_path)
    UI.user_error!("App Store Connect API key not found at path: #{api_key_path}")
  end
  
  # Read required environment variables
  key_id = ENV['APP_STORE_CONNECT_API_KEY_KEY_ID']
  issuer_id = ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
  
  if key_id.nil? || issuer_id.nil?
    UI.user_error!("Missing required environment variables: APP_STORE_CONNECT_API_KEY_KEY_ID or APP_STORE_CONNECT_API_KEY_ISSUER_ID")
  end
  
  # Create JSON file required by Fastlane
  api_key_json = {
    "key_id" => key_id,
    "issuer_id" => issuer_id,
    "key" => api_key_path,
    "duration" => 1200, # 20 minutes
    "in_house" => false
  }.to_json
  
  File.write("./appstore_api_key.json", api_key_json)
  
  UI.success("App Store Connect API Key setup complete")
end

# ===========================
#       Android Lanes
# ===========================

platform :android do

  desc "Prepare the keystore file"
  lane :prepare_keystore do
    Dir.chdir(project_root) do
      keystore_file_hex = ENV['KEYSTORE_FILE_HEX']
      UI.user_error!("KEYSTORE_FILE_HEX environment variable is missing") if keystore_file_hex.nil?

      UI.message("Creating keystore from HEX...")
      File.write("bluewallet-release-key.keystore.hex", keystore_file_hex)

      # Using shell command here as there's no direct Fastlane action for xxd conversion
      sh("xxd -plain -revert bluewallet-release-key.keystore.hex > bluewallet-release-key.keystore") do |status|
        UI.user_error!("Error reverting hex to keystore") unless status.success?
      end
      UI.message("Keystore created successfully.")

      File.delete("bluewallet-release-key.keystore.hex")
    end
  end

  desc "Update version, build number, and sign APK"
  lane :update_version_build_and_sign_apk do
    Dir.chdir(project_root) do
      build_number = ENV['BUILD_NUMBER']
      UI.user_error!("BUILD_NUMBER environment variable is missing") if build_number.nil?
 
      # Extract versionName from build.gradle using Ruby file operations instead of grep
      build_gradle_path = "android/app/build.gradle"
      build_gradle_contents = File.read(build_gradle_path)
      version_match = build_gradle_contents.match(/versionName\s+"([^"]+)"/)
      version_name = version_match ? version_match[1] : nil
      UI.user_error!("Failed to extract versionName from build.gradle") if version_name.nil? || version_name.empty?
 
      # Update versionCode in build.gradle
      UI.message("Updating versionCode in build.gradle to #{build_number}...")
      new_build_gradle_contents = build_gradle_contents.gsub(/versionCode\s+\d+/, "versionCode #{build_number}")
      File.write(build_gradle_path, new_build_gradle_contents)
 
      # Determine branch name and sanitize it
      branch_name = ENV['GITHUB_HEAD_REF'] || `git rev-parse --abbrev-ref HEAD`.strip
      branch_name = branch_name.gsub(/[^a-zA-Z0-9_-]/, '_') # Replace non-alphanumeric characters with underscore
      branch_name = 'master' if branch_name.nil? || branch_name.empty?
 
      # Define APK name based on branch
      signed_apk_name = branch_name != 'master' ? 
        "BlueWallet-#{version_name}-#{build_number}-#{branch_name}.apk" : 
        "BlueWallet-#{version_name}-#{build_number}.apk"
 
      # Define paths
      unsigned_apk_path = "android/app/build/outputs/apk/release/app-release-unsigned.apk"
      signed_apk_path = "android/app/build/outputs/apk/release/#{signed_apk_name}"
 
      # Build APK using Fastlane's gradle action instead of shell
      UI.message("Building APK...")
      gradle(
        task: "assembleRelease",
        project_dir: "android",
        properties: {
          "android.optional.compilation": "PREFER_KOTLIN_WORKER",
        },
        flags: "--no-daemon"
      )
      UI.message("APK build completed.")
 
      # Rename APK
      if File.exist?(unsigned_apk_path)
        UI.message("Renaming APK to #{signed_apk_name}...")
        FileUtils.mv(unsigned_apk_path, signed_apk_path)
        ENV['APK_OUTPUT_PATH'] = File.expand_path(signed_apk_path)
      else
        UI.error("Unsigned APK not found at path: #{unsigned_apk_path}")
        next
      end
 
      # Sign APK - no direct Fastlane action for this specific task
      UI.message("Signing APK with apksigner...")
      apksigner_path = Dir.glob("#{ENV['ANDROID_HOME']}/build-tools/*/apksigner").sort.last
      UI.user_error!("apksigner not found in Android build-tools") if apksigner_path.nil? || apksigner_path.empty?
      sh("#{apksigner_path} sign --ks #{project_root}/bluewallet-release-key.keystore --ks-pass=pass:#{ENV['KEYSTORE_PASSWORD']} #{signed_apk_path}")
      UI.message("APK signed successfully: #{signed_apk_path}")
    end
  end
end

  desc "Upload APK to BrowserStack and post result as PR comment"
  lane :upload_to_browserstack_and_comment do
    Dir.chdir(project_root) do
      # Determine APK path using Fastlane's find_files instead of shell find command
      apk_path = ENV['APK_PATH']
      if apk_path.nil? || apk_path.empty?
        UI.message("No APK path provided, searching for APK...")
        apk_files = Dir.glob("./**/*.apk")
        apk_path = apk_files.first
        UI.user_error!("No APK file found") if apk_path.nil? || apk_path.empty?
      end

      # Upload to BrowserStack
      UI.message("Uploading APK to BrowserStack: #{apk_path}...")
      upload_to_browserstack_app_live(
        file_path: apk_path,
        browserstack_username: ENV['BROWSERSTACK_USERNAME'],
        browserstack_access_key: ENV['BROWSERSTACK_ACCESS_KEY']
      )

      # Extract BrowserStack URL
      app_url = ENV['BROWSERSTACK_LIVE_APP_ID']
      UI.user_error!("BrowserStack upload failed, no app URL returned") if app_url.nil? || app_url.empty?

      # Prepare PR comment
      apk_filename = File.basename(apk_path)
      apk_download_url = ENV['APK_OUTPUT_PATH'] # Ensure this path is accessible
      browserstack_hashed_id = app_url.gsub('bs://', '')
      pr_number = ENV['GITHUB_PR_NUMBER']

      comment_identifier = '### APK Successfully Uploaded to BrowserStack'

      comment = <<~COMMENT
        #{comment_identifier}

        You can test it on the following devices:
        
        - [Google Pixel 9 (Android 15)](https://app-live.browserstack.com/dashboard#os=android&os_version=15.0&device=Google+Pixel+8&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 8 (Android 14)](https://app-live.browserstack.com/dashboard#os=android&os_version=14.0&device=Google+Pixel+8&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 7 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Google+Pixel+7&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 5 (Android 12)](https://app-live.browserstack.com/dashboard#os=android&os_version=12.0&device=Google+Pixel+5&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 3a (Android 9)](https://app-live.browserstack.com/dashboard#os=android&os_version=9.0&device=Google+Pixel+3a&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        
        - [Samsung Galaxy Z Fold 6 (Android 14)](https://app-live.browserstack.com/dashboard#os=android&os_version=14.0&device=Samsung+Galaxy+Z+Fold+6&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Z Fold 5 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Samsung+Galaxy+Z+Fold+5&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Tab S9 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Samsung+Galaxy+Tab+S9&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Note 9 (Android 8.1)](https://app-live.browserstack.com/dashboard#os=android&os_version=8.1&device=Samsung+Galaxy+Note+9&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)

        - [OnePlus 11R (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=OnePlus+11R&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        **Filename**: [#{apk_filename}](#{apk_download_url})
        **BrowserStack App URL**: #{app_url}
      COMMENT

      # Delete Previous BrowserStack Comments
      if pr_number
        begin
          repo = ENV['GITHUB_REPOSITORY'] # Format: "owner/repo"
          repo_owner, repo_name = repo.split('/')

          UI.message("Fetching existing comments for PR ##{pr_number}...")
          
          # No direct Fastlane alternative for GitHub API calls
          comments_json = `gh api -X GET /repos/#{repo_owner}/#{repo_name}/issues/#{pr_number}/comments`
          comments = JSON.parse(comments_json)

          comments.each do |comment|
            if comment['body'].start_with?(comment_identifier)
              comment_id = comment['id']
              UI.message("Deleting previous comment ID: #{comment_id}...")
              `gh api -X DELETE /repos/#{repo_owner}/#{repo_name}/issues/comments/#{comment_id}`
              UI.success("Deleted comment ID: #{comment_id}")
            end
          end

        rescue => e
          UI.error("Failed to delete previous comments: #{e.message}")
        end
      else
        UI.important("No PR number found. Skipping deletion of previous comments.")
      end

      # Post New Comment to PR
      if pr_number
        begin
          escaped_comment = comment.gsub("'", "'\\''")
          # No direct Fastlane alternative for GitHub CLI operations
          sh("GH_TOKEN=#{ENV['GH_TOKEN']} gh pr comment #{pr_number} --body '#{escaped_comment}'")
          UI.success("Posted new comment to PR ##{pr_number}")
        rescue => e
          UI.error("Failed to post comment to PR: #{e.message}")
        end
      else
        UI.important("No PR number found. Skipping PR comment.")
      end
    end
end


# ===========================
#       iOS Lanes
# ===========================

platform :ios do
  # Add helper methods for error handling and retries
  def ensure_env_vars(vars)
    vars.each do |var|
      UI.user_error!("#{var} environment variable is missing") if ENV[var].nil? || ENV[var].empty?
    end
  end
  
  def log_success(message)
    UI.success("‚úÖ #{message}")
  end
  
  def log_error(message)
    UI.error("‚ùå #{message}")
  end
  
  # Method to safely call actions with retry logic
  def with_retry(max_attempts = 3, action_name = "")
    attempts = 0
    begin
      attempts += 1
      yield
    rescue => e
      if attempts < max_attempts
        wait_time = 10 * attempts
        log_error("Attempt #{attempts}/#{max_attempts} for #{action_name} failed: #{e.message}")
        UI.message("Retrying in #{wait_time} seconds...")
        sleep(wait_time)
        retry
      else
        log_error("#{action_name} failed after #{max_attempts} attempts: #{e.message}")
        raise e
      end
    end
  end

  desc "Register new devices from a file"
  lane :register_devices_from_txt do
    UI.message("Registering new devices from file...")

    # Allow specifying a custom path but use a default if not provided
    csv_path = ENV['DEVICES_FILE'] || File.join(project_root, "devices.txt")
    
    unless File.exist?(csv_path)
      UI.user_error!("Devices file not found at path: #{csv_path}")
    end

    # Register devices using the devices_file parameter
    register_devices(
      devices_file: csv_path
    )

    UI.message("Devices registered successfully.")

    # Update provisioning profiles for all app identifiers
    app_identifiers.each do |app_identifier|
      match(
        type: "development", 
        app_identifier: app_identifier,
        readonly: false, # Regenerate provisioning profile if needed
        force_for_new_devices: true,
        clone_branch_directly: true
      )
    end

    UI.message("Development provisioning profiles updated.")
  end

  desc "Create a temporary keychain"
  lane :create_temp_keychain do
    UI.message("Creating a temporary keychain...")

    create_keychain(
      name: "temp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: true
    )

    UI.message("Temporary keychain created successfully.")
  end

  desc "Synchronize certificates and provisioning profiles"
  lane :setup_provisioning_profiles do
    required_vars = ["GIT_ACCESS_TOKEN", "GIT_URL", "ITC_TEAM_ID", "ITC_TEAM_NAME", "KEYCHAIN_PASSWORD"]
    ensure_env_vars(required_vars)
    
    UI.message("Setting up provisioning profiles...")
    
    # Iterate over app identifiers to fetch provisioning profiles
    app_identifiers.each do |app_identifier|
      with_retry(3, "Fetching provisioning profile for #{app_identifier}") do
        UI.message("Fetching provisioning profile for #{app_identifier}...")
        match(
          git_basic_authorization: ENV["GIT_ACCESS_TOKEN"],
          git_url: ENV["GIT_URL"],
          type: "appstore",
          clone_branch_directly: true,
          platform: "ios",
          app_identifier: app_identifier,
          team_id: ENV["ITC_TEAM_ID"],
          team_name: ENV["ITC_TEAM_NAME"],
          readonly: true,
          keychain_name: "temp_keychain",
          keychain_password: ENV["KEYCHAIN_PASSWORD"],
        )
        log_success("Successfully fetched provisioning profile for #{app_identifier}")
      end
    end

    log_success("All provisioning profiles set up")
  end

  desc "Fetch development certificates and provisioning profiles for Mac Catalyst"
  lane :fetch_dev_profiles_catalyst do
    match(
      type: "development",
      platform: "catalyst",
      app_identifier: app_identifiers,
      readonly: true,
      clone_branch_directly: true
    )
  end

  desc "Fetch App Store certificates and provisioning profiles for Mac Catalyst"
  lane :fetch_appstore_profiles_catalyst do
    match(
      type: "appstore",
      platform: "catalyst",
      app_identifier: app_identifiers,
      readonly: true,
      clone_branch_directly: true
    )
  end

  desc "Setup provisioning profiles for Mac Catalyst"
  lane :setup_catalyst_provisioning_profiles do
    app_identifiers.each do |app_identifier|
      match(
        type: "development",
        platform: "catalyst",
        app_identifier: app_identifier,
        readonly: false,
        force_for_new_devices: true,
        clone_branch_directly: true
      )

      match(
        type: "appstore",
        platform: "catalyst",
        app_identifier: app_identifier,
        readonly: false,
        clone_branch_directly: true
      )
    end
  end

  desc "Clear derived data"
  lane :clear_derived_data_lane do
    UI.message("Clearing derived data...")
    clear_derived_data
  end

  desc "Increment build number"
  lane :increment_build_number_lane do
    UI.message("Incrementing build number to current timestamp...")
    
    # Set the new build number
    increment_build_number(
      xcodeproj: "ios/BlueWallet.xcodeproj", 
      build_number: ENV["NEW_BUILD_NUMBER"]
    )
    UI.message("Build number set to: #{ENV['NEW_BUILD_NUMBER']}")
  end

  desc "Install CocoaPods dependencies"
  lane :install_pods do
    UI.message("Installing CocoaPods dependencies...")
    cocoapods(podfile: "ios/Podfile")
  end

  desc "Upload IPA to TestFlight"
  lane :upload_to_testflight_lane do

  branch_name = ENV['BRANCH_NAME'] || "unknown-branch"
  last_commit_message = ENV['LATEST_COMMIT_MESSAGE'] || "No commit message found"

  changelog = <<~CHANGELOG
    Build Information:
  CHANGELOG

  # Include the branch name only if it is not 'master'
  if branch_name != 'master'
    changelog += <<~CHANGELOG
      - Branch: #{branch_name}
    CHANGELOG
  end

  changelog += <<~CHANGELOG
    - Commit: #{last_commit_message}
  CHANGELOG

  ipa_path = ENV['IPA_OUTPUT_PATH']
  if ipa_path.nil? || ipa_path.empty? || !File.exist?(ipa_path)
    UI.user_error!("IPA file not found at path: #{ipa_path}")
  end

  UI.message("Uploading IPA to TestFlight from path: #{ipa_path}")
  UI.message("Changelog:\n#{changelog}")

  upload_to_testflight(
    api_key_path: "./appstore_api_key.json",
    ipa: ipa_path,
    skip_waiting_for_build_processing: true,
    changelog: changelog
  )

  UI.success("Successfully uploaded IPA to TestFlight!")
end
desc "Upload iOS source maps to Bugsnag"
lane :upload_bugsnag_sourcemaps do
  bugsnag_api_key = ENV['BUGSNAG_API_KEY']
  bugsnag_release_stage = ENV['BUGSNAG_RELEASE_STAGE'] || "production"
  version = ENV['PROJECT_VERSION']
  build_number = ENV['NEW_BUILD_NUMBER']

  UI.user_error!("BUGSNAG_API_KEY environment variable is missing") if bugsnag_api_key.nil?
  UI.user_error!("PROJECT_VERSION environment variable is missing") if version.nil?
  UI.user_error!("NEW_BUILD_NUMBER environment variable is missing") if build_number.nil?

  # Check multiple possible locations for source maps
  source_map_paths = [
    "./ios/build/Build/Products/Release-iphonesimulator/main.jsbundle.map",
    "./ios/main.jsbundle.map",
    "./ios/assets/main.jsbundle.map"
  ]
  
  ios_sourcemap = nil
  source_map_paths.each do |path|
    if File.exist?(path)
      ios_sourcemap = path
      break
    end
  end

  if ios_sourcemap
    UI.message("Uploading iOS source map from #{ios_sourcemap} to Bugsnag...")
    bugsnag_sourcemaps_upload(
      api_key: bugsnag_api_key,
      source_map: ios_sourcemap,
      minified_file: "./ios/main.jsbundle",
      code_bundle_id: "#{version}-#{build_number}",
      release_stage: bugsnag_release_stage,
      app_version: version
    )
    UI.success("iOS source map uploaded successfully.")
  else
    UI.error("iOS source map not found. Checked paths: #{source_map_paths.join(', ')}")
  end
end

# ===========================
#       Global Lanes
# ===========================

desc "Deploy to TestFlight"
lane :deploy do |options|
  UI.message("Starting deployment process...")

  # Update WWDR Certificate
  update_wwdr_certificate

  # Setup App Store Connect API Key
  setup_app_store_connect_api_key

  # Setup Provisioning Profiles
  setup_provisioning_profiles

  # Clear Derived Data
  clear_derived_data_lane

  # Increment Build Number
  increment_build_number_lane

  # Install CocoaPods if not already installed
  unless File.directory?("Pods")
    install_pods
  end

  # Build the iOS App
  build_app_lane

  # Upload IPA to TestFlight
  upload_to_testflight_lane

  # Clean up and delete the temporary keychain
  delete_keychain(name: "temp_keychain")

  # Mark deployment as completed for the current commit
  last_commit = last_git_commit
  already_built_flag = ".already_built_#{last_commit[:sha]}"
  File.write(already_built_flag, Time.now.to_s)
end

desc "Interactively update 'What's New' section in App Store Connect"
lane :update_release_notes do |options|
  require 'spaceship'
  
  UI.message("üìù Interactive Release Notes Update üìù")
  UI.message("This will update the 'What's New' section for the next version in App Store Connect.")
  UI.message("=================================================================")
  
  # Get release notes from user input
  UI.message("\nPlease enter your release notes (press Enter twice when finished):")
  UI.message("Markdown format is supported. Keep it concise and clear.\n")
  
  release_notes_lines = []
  while (line = STDIN.gets) do
    break if line.strip.empty? && !release_notes_lines.empty?
    release_notes_lines << line
  end
  
  release_notes_text = release_notes_lines.join("").strip
  
  if release_notes_text.empty?
    UI.user_error!("No release notes entered. Operation cancelled.")
  end
  
  # Show preview with proper formatting
  UI.header("Preview of Release Notes:")
  UI.message(release_notes_text)
  UI.message("\n")
  
  # Connect to App Store Connect
  UI.message("Connecting to App Store Connect...")
  
  begin
    Spaceship::ConnectAPI.login
    UI.success("‚úÖ Successfully connected to App Store Connect")
  rescue => e
    UI.user_error!("‚ùå Failed to connect to App Store Connect: #{e.message}")
  end
  
  app = Spaceship::ConnectAPI::App.find(app_identifiers.first)
  UI.user_error!("Could not find the app with identifier: #{app_identifiers.first}") unless app
  
  # Find or create editable version
  UI.message("Looking for a version in 'Prepare for Submission' state...")
  
  retries = 3
  prepare_version = nil
  
  begin
    prepare_version = app.get_edit_app_store_version(platform: Spaceship::ConnectAPI::Platform::IOS)
    
    if prepare_version.nil?
      UI.important("No version found in 'Prepare for Submission' state.")
      
      if UI.confirm("Do you want to create a new version?")
        UI.message("Finding the latest version...")
        latest_version = app.get_latest_version(platform: Spaceship::ConnectAPI::Platform::IOS)
        
        # Calculate next version number - handle both semver formats
        version_parts = latest_version.version_string.split('.')
        if version_parts.length >= 3
          # Semantic versioning - increment patch version
          version_parts[-1] = (version_parts[-1].to_i + 1).to_s
          new_version_number = version_parts.join('.')
        else
          # Simple versioning - increment by 0.1
          new_version_number = (latest_version.version_string.to_f + 0.1).round(1).to_s
        end
        
        # Allow user to customize version number
        custom_version = UI.input("Enter version number (default: #{new_version_number}):")
        new_version_number = custom_version unless custom_version.strip.empty?
        
        UI.message("Creating new version #{new_version_number}...")
        prepare_version = app.create_version!(platform: Spaceship::ConnectAPI::Platform::IOS, version_string: new_version_number)
        UI.success("‚úÖ Created new version: #{new_version_number}")
      else
        UI.user_error!("Operation cancelled. No version to update.")
      end
    else
      UI.success("‚úÖ Found existing version in 'Prepare for Submission': #{prepare_version.version_string}")
    end
  rescue => e
    retries -= 1
    if retries > 0
      UI.error("Error: #{e.message}. Retrying... (#{retries} attempts left)")
      sleep(5)
      retry
    else
      UI.user_error!("‚ùå Failed to access or create app version: #{e.message}")
    end
  end
  
  # Extract available localizations
  UI.message("Fetching available localizations...")
  localized_metadata = prepare_version.get_app_store_version_localizations
  enabled_locales = localized_metadata.map(&:locale)
  
  UI.message("Found #{enabled_locales.count} enabled locales.")
  
  # Ask which locales to update
  selected_locales = []
  
  if UI.confirm("Do you want to update all available localizations with the same text? (No to select specific ones)")
    selected_locales = enabled_locales
  else
    UI.message("Available locales:")
    
    # Display locales in a formatted way
    locale_display = {}
    enabled_locales.each_with_index do |locale, index|
      locale_name = case locale
                    when 'en-US' then 'English (US) - Primary'
                    when 'ar-SA' then 'Arabic'
                    when 'zh-Hans' then 'Chinese (Simplified)'
                    when 'hr' then 'Croatian'
                    when 'da' then 'Danish'
                    when 'nl-NL' then 'Dutch'
                    when 'fi' then 'Finnish'
                    when 'fr-FR' then 'French'
                    when 'de-DE' then 'German'
                    when 'el' then 'Greek'
                    when 'he' then 'Hebrew'
                    when 'hu' then 'Hungarian'
                    when 'it' then 'Italian'
                    when 'ja' then 'Japanese'
                    when 'ms' then 'Malay'
                    when 'nb' then 'Norwegian'
                    when 'pl' then 'Polish'
                    when 'pt-BR' then 'Portuguese (Brazil)'
                    when 'pt-PT' then 'Portuguese (Portugal)'
                    when 'ro' then 'Romanian'
                    when 'ru' then 'Russian'
                    when 'es-MX' then 'Spanish (Mexico)'
                    when 'es-ES' then 'Spanish (Spain)'
                    when 'sv' then 'Swedish'
                    when 'th' then 'Thai'
                    else locale
                    end
      
      locale_display[locale] = "#{index + 1}. #{locale_name} (#{locale})"
      UI.message(locale_display[locale])
    end
    
    UI.message("\nEnter the numbers of locales to update (comma-separated, e.g. '1,3,5'), or press Enter for all:")
    locale_input = STDIN.gets.strip
    
    if locale_input.empty?
      selected_locales = enabled_locales
    else
      selected_indices = locale_input.split(',').map(&:strip).map(&:to_i)
      selected_indices.each do |idx|
        if idx > 0 && idx <= enabled_locales.length
          selected_locales << enabled_locales[idx - 1]
        end
      end
      
      # Ensure at least primary locale (en-US) is selected
      if selected_locales.empty? || !selected_locales.include?('en-US')
        if enabled_locales.include?('en-US')
          selected_locales << 'en-US'
          UI.important("Adding English (US) as it's required.")
        end
      end
    end
  end
  
  # Final confirmation with selected locales
  UI.important("You are about to update release notes for version #{prepare_version.version_string}")
  UI.important("Selected locales: #{selected_locales.count > 5 ? "All #{selected_locales.count} locales" : selected_locales.join(', ')}")
  UI.important("Release notes:\n#{release_notes_text}")
  
  unless UI.confirm("Do you want to proceed with these updates?")
    UI.user_error!("Operation cancelled by user.")
  end
  
  # Update release notes
  UI.message("Updating release notes...")
  
  update_count = 0
  selected_locales.each do |locale|
    app_store_version_localization = localized_metadata.find { |loc| loc.locale == locale }
    
    if app_store_version_localization
      begin
        app_store_version_localization.update(attributes: { "whats_new" => release_notes_text })
        update_count += 1
        UI.success("‚úÖ Updated #{locale}")
      rescue => e
        UI.error("‚ùå Failed to update #{locale}: #{e.message}")
      end
    else
      UI.error("‚ùå No localization found for locale #{locale}")
    end
  end
  
  # Final result
  if update_count == selected_locales.count
    UI.success("‚úÖ Successfully updated release notes for all selected locales.")
  elsif update_count > 0
    UI.important("‚ö†Ô∏è Updated release notes for #{update_count} out of #{selected_locales.count} selected locales.")
  else
    UI.error("‚ùå Failed to update release notes for any locale.")
  end
  
  # Save release notes to file for future reference
  timestamp = Time.now.strftime("%Y%m%d_%H%M%S")
  release_notes_file = "release_notes_#{prepare_version.version_string}_#{timestamp}.txt"
  File.write(release_notes_file, release_notes_text)
  UI.success("üìù Saved release notes to #{release_notes_file}")
end
end