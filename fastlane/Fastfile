# Define app identifiers once for reuse across lanes
def app_identifiers
  [
    "io.bluewallet.bluewallet",
    "io.bluewallet.bluewallet.watch",
    "io.bluewallet.bluewallet.watch.extension",
    "io.bluewallet.bluewallet.Stickers",
    "io.bluewallet.bluewallet.MarketWidget"
  ]
end

default_platform(:android)
project_root = File.expand_path("..", __dir__)

# ===========================
#       Helper Methods
# ===========================

desc "Update Apple Worldwide Developer Relations certificate"
lane :update_wwdr_certificate do
  UI.message("Updating Apple WWDR certificate...")
  
  sh("curl -sL https://developer.apple.com/certificationauthority/AppleWWDRCA.cer -o /tmp/AppleWWDRCA.cer")
  sh("security import /tmp/AppleWWDRCA.cer -k /Library/Keychains/System.keychain -T /usr/bin/codesign")
  
  UI.message("Apple WWDR certificate updated successfully")
rescue => e
  UI.important("Failed to update WWDR certificate: #{e.message}")
  UI.important("This is not critical, continuing with the process...")
end

desc "Setup App Store Connect API Key"
lane :setup_app_store_connect_api_key do
  UI.message("Setting up App Store Connect API Key...")
  
  # Check if the key file exists
  api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH'] || "./appstore_api_key.p8"
  api_key_content = ENV['APP_STORE_CONNECT_API_KEY_CONTENT']
  
  if api_key_content && !File.exist?(api_key_path)
    UI.message("Creating API key file from content...")
    File.write(api_key_path, api_key_content)
  end
  
  unless File.exist?(api_key_path)
    UI.user_error!("App Store Connect API key not found at path: #{api_key_path}")
  end
  
  # Read required environment variables
  key_id = ENV['APP_STORE_CONNECT_API_KEY_KEY_ID']
  issuer_id = ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
  
  if key_id.nil? || issuer_id.nil?
    UI.user_error!("Missing required environment variables: APP_STORE_CONNECT_API_KEY_KEY_ID or APP_STORE_CONNECT_API_KEY_ISSUER_ID")
  end
  
  # Create JSON file required by Fastlane
  api_key_json = {
    "key_id" => key_id,
    "issuer_id" => issuer_id,
    "key" => api_key_path,
    "duration" => 1200, # 20 minutes
    "in_house" => false
  }.to_json
  
  File.write("./appstore_api_key.json", api_key_json)
  
  UI.success("App Store Connect API Key setup complete")
end

# ===========================
#       Android Lanes
# ===========================

platform :android do

  desc "Prepare the keystore file"
  lane :prepare_keystore do
    Dir.chdir(project_root) do
      keystore_file_hex = ENV['KEYSTORE_FILE_HEX']
      UI.user_error!("KEYSTORE_FILE_HEX environment variable is missing") if keystore_file_hex.nil?

      UI.message("Creating keystore from HEX...")
      File.write("bluewallet-release-key.keystore.hex", keystore_file_hex)

      # Using shell command here as there's no direct Fastlane action for xxd conversion
      sh("xxd -plain -revert bluewallet-release-key.keystore.hex > bluewallet-release-key.keystore") do |status|
        UI.user_error!("Error reverting hex to keystore") unless status.success?
      end
      UI.message("Keystore created successfully.")

      File.delete("bluewallet-release-key.keystore.hex")
    end
  end

  desc "Update version, build number, and sign APK"
  lane :update_version_build_and_sign_apk do
    Dir.chdir(project_root) do
      build_number = ENV['BUILD_NUMBER']
      UI.user_error!("BUILD_NUMBER environment variable is missing") if build_number.nil?
 
      # Extract versionName from build.gradle using Ruby file operations instead of grep
      build_gradle_path = "android/app/build.gradle"
      build_gradle_contents = File.read(build_gradle_path)
      version_match = build_gradle_contents.match(/versionName\s+"([^"]+)"/)
      version_name = version_match ? version_match[1] : nil
      UI.user_error!("Failed to extract versionName from build.gradle") if version_name.nil? || version_name.empty?
 
      # Update versionCode in build.gradle
      UI.message("Updating versionCode in build.gradle to #{build_number}...")
      new_build_gradle_contents = build_gradle_contents.gsub(/versionCode\s+\d+/, "versionCode #{build_number}")
      File.write(build_gradle_path, new_build_gradle_contents)
 
      # Determine branch name and sanitize it
      branch_name = ENV['GITHUB_HEAD_REF'] || `git rev-parse --abbrev-ref HEAD`.strip
      branch_name = branch_name.gsub(/[^a-zA-Z0-9_-]/, '_') # Replace non-alphanumeric characters with underscore
      branch_name = 'master' if branch_name.nil? || branch_name.empty?
 
      # Define APK name based on branch
      signed_apk_name = branch_name != 'master' ? 
        "BlueWallet-#{version_name}-#{build_number}-#{branch_name}.apk" : 
        "BlueWallet-#{version_name}-#{build_number}.apk"
 
      # Define paths
      unsigned_apk_path = "android/app/build/outputs/apk/release/app-release-unsigned.apk"
      signed_apk_path = "android/app/build/outputs/apk/release/#{signed_apk_name}"
 
      # Build APK using Fastlane's gradle action instead of shell
      UI.message("Building APK...")
      gradle(
        task: "assembleRelease",
        project_dir: "android",
        properties: {
          "android.optional.compilation": "PREFER_KOTLIN_WORKER",
        },
        flags: "--no-daemon"
      )
      UI.message("APK build completed.")
 
      # Rename APK
      if File.exist?(unsigned_apk_path)
        UI.message("Renaming APK to #{signed_apk_name}...")
        FileUtils.mv(unsigned_apk_path, signed_apk_path)
        ENV['APK_OUTPUT_PATH'] = File.expand_path(signed_apk_path)
      else
        UI.error("Unsigned APK not found at path: #{unsigned_apk_path}")
        next
      end
 
      # Sign APK - no direct Fastlane action for this specific task
      UI.message("Signing APK with apksigner...")
      apksigner_path = Dir.glob("#{ENV['ANDROID_HOME']}/build-tools/*/apksigner").sort.last
      UI.user_error!("apksigner not found in Android build-tools") if apksigner_path.nil? || apksigner_path.empty?
      sh("#{apksigner_path} sign --ks #{project_root}/bluewallet-release-key.keystore --ks-pass=pass:#{ENV['KEYSTORE_PASSWORD']} #{signed_apk_path}")
      UI.message("APK signed successfully: #{signed_apk_path}")
    end
  end
end

  desc "Upload APK to BrowserStack and post result as PR comment"
  lane :upload_to_browserstack_and_comment do
    Dir.chdir(project_root) do
      # Determine APK path using Fastlane's find_files instead of shell find command
      apk_path = ENV['APK_PATH']
      if apk_path.nil? || apk_path.empty?
        UI.message("No APK path provided, searching for APK...")
        apk_files = Dir.glob("./**/*.apk")
        apk_path = apk_files.first
        UI.user_error!("No APK file found") if apk_path.nil? || apk_path.empty?
      end

      # Upload to BrowserStack
      UI.message("Uploading APK to BrowserStack: #{apk_path}...")
      upload_to_browserstack_app_live(
        file_path: apk_path,
        browserstack_username: ENV['BROWSERSTACK_USERNAME'],
        browserstack_access_key: ENV['BROWSERSTACK_ACCESS_KEY']
      )

      # Extract BrowserStack URL
      app_url = ENV['BROWSERSTACK_LIVE_APP_ID']
      UI.user_error!("BrowserStack upload failed, no app URL returned") if app_url.nil? || app_url.empty?

      # Prepare PR comment
      apk_filename = File.basename(apk_path)
      apk_download_url = ENV['APK_OUTPUT_PATH'] # Ensure this path is accessible
      browserstack_hashed_id = app_url.gsub('bs://', '')
      pr_number = ENV['GITHUB_PR_NUMBER']

      comment_identifier = '### APK Successfully Uploaded to BrowserStack'

      comment = <<~COMMENT
        #{comment_identifier}

        You can test it on the following devices:
        
        - [Google Pixel 9 (Android 15)](https://app-live.browserstack.com/dashboard#os=android&os_version=15.0&device=Google+Pixel+8&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 8 (Android 14)](https://app-live.browserstack.com/dashboard#os=android&os_version=14.0&device=Google+Pixel+8&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 7 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Google+Pixel+7&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 5 (Android 12)](https://app-live.browserstack.com/dashboard#os=android&os_version=12.0&device=Google+Pixel+5&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Google Pixel 3a (Android 9)](https://app-live.browserstack.com/dashboard#os=android&os_version=9.0&device=Google+Pixel+3a&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        
        - [Samsung Galaxy Z Fold 6 (Android 14)](https://app-live.browserstack.com/dashboard#os=android&os_version=14.0&device=Samsung+Galaxy+Z+Fold+6&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Z Fold 5 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Samsung+Galaxy+Z+Fold+5&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Tab S9 (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=Samsung+Galaxy+Tab+S9&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        - [Samsung Galaxy Note 9 (Android 8.1)](https://app-live.browserstack.com/dashboard#os=android&os_version=8.1&device=Samsung+Galaxy+Note+9&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)

        - [OnePlus 11R (Android 13)](https://app-live.browserstack.com/dashboard#os=android&os_version=13.0&device=OnePlus+11R&app_hashed_id=#{browserstack_hashed_id}&scale_to_fit=true&speed=1&start=true&browser=chrome)
        **Filename**: [#{apk_filename}](#{apk_download_url})
        **BrowserStack App URL**: #{app_url}
      COMMENT

      # Delete Previous BrowserStack Comments
      if pr_number
        begin
          repo = ENV['GITHUB_REPOSITORY'] # Format: "owner/repo"
          repo_owner, repo_name = repo.split('/')

          UI.message("Fetching existing comments for PR ##{pr_number}...")
          
          # No direct Fastlane alternative for GitHub API calls
          comments_json = `gh api -X GET /repos/#{repo_owner}/#{repo_name}/issues/#{pr_number}/comments`
          comments = JSON.parse(comments_json)

          comments.each do |comment|
            if comment['body'].start_with?(comment_identifier)
              comment_id = comment['id']
              UI.message("Deleting previous comment ID: #{comment_id}...")
              `gh api -X DELETE /repos/#{repo_owner}/#{repo_name}/issues/comments/#{comment_id}`
              UI.success("Deleted comment ID: #{comment_id}")
            end
          end

        rescue => e
          UI.error("Failed to delete previous comments: #{e.message}")
        end
      else
        UI.important("No PR number found. Skipping deletion of previous comments.")
      end

      # Post New Comment to PR
      if pr_number
        begin
          escaped_comment = comment.gsub("'", "'\\''")
          # No direct Fastlane alternative for GitHub CLI operations
          sh("GH_TOKEN=#{ENV['GH_TOKEN']} gh pr comment #{pr_number} --body '#{escaped_comment}'")
          UI.success("Posted new comment to PR ##{pr_number}")
        rescue => e
          UI.error("Failed to post comment to PR: #{e.message}")
        end
      else
        UI.important("No PR number found. Skipping PR comment.")
      end
    end
end


# ===========================
#       iOS Lanes
# ===========================

platform :ios do
  # Add helper methods for error handling and retries
  def ensure_env_vars(vars)
    vars.each do |var|
      UI.user_error!("#{var} environment variable is missing") if ENV[var].nil? || ENV[var].empty?
    end
  end
  
  def log_success(message)
    UI.success("✅ #{message}")
  end
  
  def log_error(message)
    UI.error("❌ #{message}")
  end
  
  # Method to safely call actions with retry logic
  def with_retry(max_attempts = 3, action_name = "")
    attempts = 0
    begin
      attempts += 1
      yield
    rescue => e
      if attempts < max_attempts
        wait_time = 10 * attempts
        log_error("Attempt #{attempts}/#{max_attempts} for #{action_name} failed: #{e.message}")
        UI.message("Retrying in #{wait_time} seconds...")
        sleep(wait_time)
        retry
      else
        log_error("#{action_name} failed after #{max_attempts} attempts: #{e.message}")
        raise e
      end
    end
  end

  desc "Register new devices from a file"
  lane :register_devices_from_txt do
    UI.message("Registering new devices from file...")

    # Allow specifying a custom path but use a default if not provided
    csv_path = ENV['DEVICES_FILE'] || File.join(project_root, "devices.txt")
    
    unless File.exist?(csv_path)
      UI.user_error!("Devices file not found at path: #{csv_path}")
    end

    # Register devices using the devices_file parameter
    register_devices(
      devices_file: csv_path
    )

    UI.message("Devices registered successfully.")

    # Update provisioning profiles for all app identifiers
    app_identifiers.each do |app_identifier|
      match(
        type: "development", 
        app_identifier: app_identifier,
        readonly: false, # Regenerate provisioning profile if needed
        force_for_new_devices: true,
        clone_branch_directly: true
      )
    end

    UI.message("Development provisioning profiles updated.")
  end

  desc "Create a temporary keychain"
  lane :create_temp_keychain do
    UI.message("Creating a temporary keychain...")

    create_keychain(
      name: "temp_keychain",
      password: ENV["KEYCHAIN_PASSWORD"],
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: true
    )

    UI.message("Temporary keychain created successfully.")
  end

  desc "Synchronize certificates and provisioning profiles"
  lane :setup_provisioning_profiles do
    required_vars = ["GIT_ACCESS_TOKEN", "GIT_URL", "ITC_TEAM_ID", "ITC_TEAM_NAME", "KEYCHAIN_PASSWORD"]
    ensure_env_vars(required_vars)
    
    UI.message("Setting up provisioning profiles...")
    
    # Iterate over app identifiers to fetch provisioning profiles
    app_identifiers.each do |app_identifier|
      with_retry(3, "Fetching provisioning profile for #{app_identifier}") do
        UI.message("Fetching provisioning profile for #{app_identifier}...")
        match(
          git_basic_authorization: ENV["GIT_ACCESS_TOKEN"],
          git_url: ENV["GIT_URL"],
          type: "appstore",
          clone_branch_directly: true,
          platform: "ios",
          app_identifier: app_identifier,
          team_id: ENV["ITC_TEAM_ID"],
          team_name: ENV["ITC_TEAM_NAME"],
          readonly: true,
          keychain_name: "temp_keychain",
          keychain_password: ENV["KEYCHAIN_PASSWORD"],
        )
        log_success("Successfully fetched provisioning profile for #{app_identifier}")
      end
    end

    log_success("All provisioning profiles set up")
  end

  desc "Fetch development certificates and provisioning profiles for Mac Catalyst"
  lane :fetch_dev_profiles_catalyst do
    match(
      type: "development",
      platform: "catalyst",
      app_identifier: app_identifiers,
      readonly: true,
      clone_branch_directly: true
    )
  end

  desc "Fetch App Store certificates and provisioning profiles for Mac Catalyst"
  lane :fetch_appstore_profiles_catalyst do
    match(
      type: "appstore",
      platform: "catalyst",
      app_identifier: app_identifiers,
      readonly: true,
      clone_branch_directly: true
    )
  end

  desc "Setup provisioning profiles for Mac Catalyst"
  lane :setup_catalyst_provisioning_profiles do
    app_identifiers.each do |app_identifier|
      match(
        type: "development",
        platform: "catalyst",
        app_identifier: app_identifier,
        readonly: false,
        force_for_new_devices: true,
        clone_branch_directly: true
      )

      match(
        type: "appstore",
        platform: "catalyst",
        app_identifier: app_identifier,
        readonly: false,
        clone_branch_directly: true
      )
    end
  end

  desc "Clear derived data"
  lane :clear_derived_data_lane do
    UI.message("Clearing derived data...")
    clear_derived_data
  end

  desc "Increment build number"
  lane :increment_build_number_lane do
    UI.message("Incrementing build number to current timestamp...")
    
    # Set the new build number
    increment_build_number(
      xcodeproj: "ios/BlueWallet.xcodeproj", 
      build_number: ENV["NEW_BUILD_NUMBER"]
    )
    UI.message("Build number set to: #{ENV['NEW_BUILD_NUMBER']}")
  end

  desc "Install CocoaPods dependencies"
  lane :install_pods do
    UI.message("Installing CocoaPods dependencies...")
    cocoapods(podfile: "ios/Podfile")
  end

  desc "Upload IPA to TestFlight"
  lane :upload_to_testflight_lane do

  branch_name = ENV['BRANCH_NAME'] || "unknown-branch"
  last_commit_message = ENV['LATEST_COMMIT_MESSAGE'] || "No commit message found"

  changelog = <<~CHANGELOG
    Build Information:
  CHANGELOG

  # Include the branch name only if it is not 'master'
  if branch_name != 'master'
    changelog += <<~CHANGELOG
      - Branch: #{branch_name}
    CHANGELOG
  end

  changelog += <<~CHANGELOG
    - Commit: #{last_commit_message}
  CHANGELOG

  ipa_path = ENV['IPA_OUTPUT_PATH']
  if ipa_path.nil? || ipa_path.empty? || !File.exist?(ipa_path)
    UI.user_error!("IPA file not found at path: #{ipa_path}")
  end

  UI.message("Uploading IPA to TestFlight from path: #{ipa_path}")
  UI.message("Changelog:\n#{changelog}")

  upload_to_testflight(
    api_key_path: "./appstore_api_key.json",
    ipa: ipa_path,
    skip_waiting_for_build_processing: true,
    changelog: changelog
  )

  UI.success("Successfully uploaded IPA to TestFlight!")
end
desc "Upload iOS source maps to Bugsnag"
lane :upload_bugsnag_sourcemaps do
  bugsnag_api_key = ENV['BUGSNAG_API_KEY']
  bugsnag_release_stage = ENV['BUGSNAG_RELEASE_STAGE'] || "production"
  version = ENV['PROJECT_VERSION']
  build_number = ENV['NEW_BUILD_NUMBER']

  UI.user_error!("BUGSNAG_API_KEY environment variable is missing") if bugsnag_api_key.nil?
  UI.user_error!("PROJECT_VERSION environment variable is missing") if version.nil?
  UI.user_error!("NEW_BUILD_NUMBER environment variable is missing") if build_number.nil?

  # Check multiple possible locations for source maps
  source_map_paths = [
    "./ios/build/Build/Products/Release-iphonesimulator/main.jsbundle.map",
    "./ios/main.jsbundle.map",
    "./ios/assets/main.jsbundle.map"
  ]
  
  ios_sourcemap = nil
  source_map_paths.each do |path|
    if File.exist?(path)
      ios_sourcemap = path
      break
    end
  end

  if ios_sourcemap
    UI.message("Uploading iOS source map from #{ios_sourcemap} to Bugsnag...")
    bugsnag_sourcemaps_upload(
      api_key: bugsnag_api_key,
      source_map: ios_sourcemap,
      minified_file: "./ios/main.jsbundle",
      code_bundle_id: "#{version}-#{build_number}",
      release_stage: bugsnag_release_stage,
      app_version: version
    )
    UI.success("iOS source map uploaded successfully.")
  else
    UI.error("iOS source map not found. Checked paths: #{source_map_paths.join(', ')}")
  end
end

  desc "Build the app for Mac Catalyst"
  lane :build_catalyst_app do
    UI.message("Building Mac Catalyst app...")
    
    # Ensure we have the right certificates and profiles
    fetch_appstore_profiles_catalyst

    # Clear derived data
    clear_derived_data_lane
    
    # Define the output path
    catalyst_directory = File.join(project_root, "ios", "build", "catalyst")
    FileUtils.mkdir_p(catalyst_directory) unless Dir.exist?(catalyst_directory)
    
    # Build Mac Catalyst app
    build_mac_app(
      workspace: File.join(project_root, "ios", "BlueWallet.xcworkspace"),
      scheme: "BlueWallet",
      platform: "mac",
      destination: "generic/platform=macOS,variant=Mac Catalyst",
      export_method: "app-store",
      skip_package_pkg: true,
      skip_package_dependencies: true,
      skip_archive: false,
      clean: true,
      configuration: "Release",
      output_directory: catalyst_directory,
      output_name: "BlueWallet-Catalyst.app",
      archive_path: File.join(catalyst_directory, "BlueWallet-Catalyst.xcarchive"),
      export_team_id: ENV["ITC_TEAM_ID"],
      buildlog_path: File.join(project_root, "ios", "build_logs", "catalyst"),
    )
    
    # Path to the built app
    catalyst_app_path = File.join(catalyst_directory, "BlueWallet-Catalyst.app")
    
    # Create a zip file for distribution
    catalyst_zip_path = File.join(catalyst_directory, "BlueWallet-Catalyst-#{ENV['PROJECT_VERSION']}_#{ENV['NEW_BUILD_NUMBER']}.zip")
    
    Dir.chdir(catalyst_directory) do
      UI.message("Creating ZIP archive at #{catalyst_zip_path}...")
      # Use ditto to preserve Mac-specific attributes
      sh("ditto -c -k --keepParent 'BlueWallet-Catalyst.app' '#{File.basename(catalyst_zip_path)}'")
    end
    
    if File.exist?(catalyst_zip_path)
      ENV['CATALYST_OUTPUT_PATH'] = catalyst_zip_path
      UI.success("✅ Mac Catalyst app successfully built and packaged at: #{catalyst_zip_path}")
      
      # Set GitHub Actions output if running in that environment
      if ENV['GITHUB_OUTPUT']
        File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
          f.puts("catalyst_output_path=#{catalyst_zip_path}")
        end
      end
    else
      UI.user_error!("Failed to create Mac Catalyst zip file")
    end
  end
  
  desc "Notarize Mac Catalyst app"
  lane :notarize_catalyst_app do
    UI.header("Notarizing Mac Catalyst app...")
    
    catalyst_zip_path = ENV['CATALYST_OUTPUT_PATH']
    UI.user_error!("CATALYST_OUTPUT_PATH environment variable is missing") unless catalyst_zip_path
    UI.user_error!("Catalyst app zip file not found at path: #{catalyst_zip_path}") unless File.exist?(catalyst_zip_path)
    
    # Ensure credentials are available
    UI.user_error!("APPLE_ID environment variable is missing") unless ENV['APPLE_ID']
    UI.user_error!("APP_SPECIFIC_PASSWORD environment variable is missing") unless ENV['APP_SPECIFIC_PASSWORD']
    
    UI.message("Uploading app for notarization: #{catalyst_zip_path}")
    
    notarize(
      package: catalyst_zip_path,
      bundle_id: app_identifiers.first,
      username: ENV['APPLE_ID'],
      asc_provider: ENV['ITC_TEAM_ID'],
      print_log: true,
      verbose: true
    )
    
    UI.success("✅ Mac Catalyst app successfully notarized!")
  end
  
  desc "Upload Mac Catalyst app to TestFlight"
  lane :upload_catalyst_to_testflight do
    UI.header("Uploading Mac Catalyst app to TestFlight...")
    
    catalyst_zip_path = ENV['CATALYST_OUTPUT_PATH']
    UI.user_error!("CATALYST_OUTPUT_PATH environment variable is missing") unless catalyst_zip_path
    UI.user_error!("Catalyst app zip file not found at path: #{catalyst_zip_path}") unless File.exist?(catalyst_zip_path)
    
    branch_name = ENV['BRANCH_NAME'] || "unknown-branch"
    last_commit_message = ENV['LATEST_COMMIT_MESSAGE'] || "No commit message found"
    
    changelog = <<~CHANGELOG
      Mac Catalyst Build Information:
    CHANGELOG
    
    # Include the branch name only if it is not 'master'
    if branch_name != 'master'
      changelog += <<~CHANGELOG
        - Branch: #{branch_name}
      CHANGELOG
    end
    
    changelog += <<~CHANGELOG
      - Commit: #{last_commit_message}
    CHANGELOG
    
    # Build and upload to App Store Connect
    build_app(
      export_method: "app-store",
      skip_build_archive: false,
      archive_path: catalyst_zip_path,
      export_team_id: ENV["ITC_TEAM_ID"]
    )
    
    upload_to_testflight(
      api_key_path: "./appstore_api_key.json",
      skip_submission: true,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      changelog: changelog
    )
    
    UI.success("✅ Mac Catalyst app successfully uploaded to TestFlight!")
  end
  
  desc "Full Mac Catalyst build and upload process"
  lane :catalyst_release do
    # Update WWDR Certificate
    update_wwdr_certificate
    
    # Setup App Store Connect API Key
    setup_app_store_connect_api_key
    
    # Increment build number if needed
    if ENV['NEW_BUILD_NUMBER'].nil?
      ENV['NEW_BUILD_NUMBER'] = Time.now.to_i.to_s
      increment_build_number_lane
    end
    
    # Build the Mac Catalyst app
    build_catalyst_app
    
    # Notarize the Mac Catalyst app
    
    notarize_catalyst_app
    
    # Upload to TestFlight
    upload_catalyst_to_testflight
    
    UI.success("✅ Mac Catalyst release process completed successfully!")
  end

  desc "Interactively update 'What's New' section in App Store Connect"
  lane :update_release_notes do |options|
    require 'spaceship'
    
    UI.message("📝 Interactive Release Notes Update 📝")
    UI.message("This will update the 'What's New' section for the next version in App Store Connect.")
    UI.message("=================================================================")
    
    # Get release notes from user input
    UI.message("\nPlease enter your release notes (press Enter twice when finished):")
    UI.message("Markdown format is supported. Keep it concise and clear.\n")
    
    release_notes_lines = []
    while (line = STDIN.gets) do
      break if line.strip.empty? && !release_notes_lines.empty?
      release_notes_lines << line
    end
    
    release_notes_text = release_notes_lines.join("").strip
    
    if release_notes_text.empty?
      UI.user_error!("No release notes entered. Operation cancelled.")
    end
    
    # Show preview with proper formatting
    UI.header("Preview of Release Notes:")
    UI.message(release_notes_text)
    UI.message("\n")
    
    # Connect to App Store Connect
    UI.message("Connecting to App Store Connect...")
    
    begin
      Spaceship::ConnectAPI.login
      UI.success("✅ Successfully connected to App Store Connect")
    rescue => e
      UI.user_error!("❌ Failed to connect to App Store Connect: #{e.message}")
    end
    
    app = Spaceship::ConnectAPI::App.find(app_identifiers.first)
    UI.user_error!("Could not find the app with identifier: #{app_identifiers.first}") unless app
    
    # Find or create editable version
    UI.message("Looking for a version in 'Prepare for Submission' state...")
    
    retries = 3
    prepare_version = nil
    
    begin
      prepare_version = app.get_edit_app_store_version(platform: Spaceship::ConnectAPI::Platform::IOS)
      
      if prepare_version.nil?
        UI.important("No version found in 'Prepare for Submission' state.")
        
        if UI.confirm("Do you want to create a new version?")
          UI.message("Finding the latest version...")
          latest_version = app.get_latest_version(platform: Spaceship::ConnectAPI::Platform::IOS)
          
          # Calculate next version number - handle both semver formats
          version_parts = latest_version.version_string.split('.')
          if version_parts.length >= 3
            # Semantic versioning - increment patch version
            version_parts[-1] = (version_parts[-1].to_i + 1).to_s
            new_version_number = version_parts.join('.')
          else
            # Simple versioning - increment by 0.1
            new_version_number = (latest_version.version_string.to_f + 0.1).round(1).to_s
          end
          
          # Allow user to customize version number
          custom_version = UI.input("Enter version number (default: #{new_version_number}):")
          new_version_number = custom_version unless custom_version.strip.empty?
          
          UI.message("Creating new version #{new_version_number}...")
          prepare_version = app.create_version!(platform: Spaceship::ConnectAPI::Platform::IOS, version_string: new_version_number)
          UI.success("✅ Created new version: #{new_version_number}")
        else
          UI.user_error!("Operation cancelled. No version to update.")
        end
      else
        UI.success("✅ Found existing version in 'Prepare for Submission': #{prepare_version.version_string}")
      end
    rescue => e
      retries -= 1
      if retries > 0
        UI.error("Error: #{e.message}. Retrying... (#{retries} attempts left)")
        sleep(5)
        retry
      else
        UI.user_error!("❌ Failed to access or create app version: #{e.message}")
      end
    end
    
    # Extract available localizations
    UI.message("Fetching available localizations...")
    localized_metadata = prepare_version.get_app_store_version_localizations
    enabled_locales = localized_metadata.map(&:locale)
    
    UI.message("Found #{enabled_locales.count} enabled locales.")
    
    # Ask which locales to update
    selected_locales = []
    
    if UI.confirm("Do you want to update all available localizations with the same text? (No to select specific ones)")
      selected_locales = enabled_locales
    else
      UI.message("Available locales:")
      
      # Display locales in a formatted way
      locale_display = {}
      enabled_locales.each_with_index do |locale, index|
        locale_name = case locale
                      when 'en-US' then 'English (US) - Primary'
                      when 'ar-SA' then 'Arabic'
                      when 'zh-Hans' then 'Chinese (Simplified)'
                      when 'hr' then 'Croatian'
                      when 'da' then 'Danish'
                      when 'nl-NL' then 'Dutch'
                      when 'fi' then 'Finnish'
                      when 'fr-FR' then 'French'
                      when 'de-DE' then 'German'
                      when 'el' then 'Greek'
                      when 'he' then 'Hebrew'
                      when 'hu' then 'Hungarian'
                      when 'it' then 'Italian'
                      when 'ja' then 'Japanese'
                      when 'ms' then 'Malay'
                      when 'nb' then 'Norwegian'
                      when 'pl' then 'Polish'
                      when 'pt-BR' then 'Portuguese (Brazil)'
                      when 'pt-PT' then 'Portuguese (Portugal)'
                      when 'ro' then 'Romanian'
                      when 'ru' then 'Russian'
                      when 'es-MX' then 'Spanish (Mexico)'
                      when 'es-ES' then 'Spanish (Spain)'
                      when 'sv' then 'Swedish'
                      when 'th' then 'Thai'
                      else locale
                      end
        
        locale_display[locale] = "#{index + 1}. #{locale_name} (#{locale})"
        UI.message(locale_display[locale])
      end
      
      UI.message("\nEnter the numbers of locales to update (comma-separated, e.g. '1,3,5'), or press Enter for all:")
      locale_input = STDIN.gets.strip
      
      if locale_input.empty?
        selected_locales = enabled_locales
      else
        selected_indices = locale_input.split(',').map(&:strip).map(&:to_i)
        selected_indices.each do |idx|
          if idx > 0 && idx <= enabled_locales.length
            selected_locales << enabled_locales[idx - 1]
          end
        end
        
        # Ensure at least primary locale (en-US) is selected
        if selected_locales.empty? || !selected_locales.include?('en-US')
          if enabled_locales.include?('en-US')
            selected_locales << 'en-US'
            UI.important("Adding English (US) as it's required.")
          end
        end
      end
    end
    
    # Final confirmation with selected locales
    UI.important("You are about to update release notes for version #{prepare_version.version_string}")
    UI.important("Selected locales: #{selected_locales.count > 5 ? "All #{selected_locales.count} locales" : selected_locales.join(', ')}")
    UI.important("Release notes:\n#{release_notes_text}")
    
    unless UI.confirm("Do you want to proceed with these updates?")
      UI.user_error!("Operation cancelled by user.")
    end
    
    # Update release notes
    UI.message("Updating release notes...")
    
    update_count = 0
    selected_locales.each do |locale|
      app_store_version_localization = localized_metadata.find { |loc| loc.locale == locale }
      
      if app_store_version_localization
        begin
          app_store_version_localization.update(attributes: { "whats_new" => release_notes_text })
          update_count += 1
          UI.success("✅ Updated #{locale}")
        rescue => e
          UI.error("❌ Failed to update #{locale}: #{e.message}")
        end
      else
        UI.error("❌ No localization found for locale #{locale}")
      end
    end
    
    # Final result
    if update_count == selected_locales.count
      UI.success("✅ Successfully updated release notes for all selected locales.")
    elsif update_count > 0
      UI.important("⚠️ Updated release notes for #{update_count} out of #{selected_locales.count} selected locales.")
    else
      UI.error("❌ Failed to update release notes for any locale.")
    end
    
    # Save release notes to file for future reference
    timestamp = Time.now.strftime("%Y%m%d_%H%M%S")
    release_notes_file = "release_notes_#{prepare_version.version_string}_#{timestamp}.txt"
    File.write(release_notes_file, release_notes_text)
    UI.success("📝 Saved release notes to #{release_notes_file}")
  end
end

# ===========================
#       Global Lanes
# ===========================

desc "Deploy to TestFlight"
lane :deploy do |options|
  UI.message("Starting deployment process...")

  # Update WWDR Certificate
  update_wwdr_certificate

  # Setup App Store Connect API Key
  setup_app_store_connect_api_key

  # Setup Provisioning Profiles
  setup_provisioning_profiles

  # Clear Derived Data
  clear_derived_data_lane

  # Increment Build Number
  increment_build_number_lane

  # Install CocoaPods if not already installed
  unless File.directory?("Pods")
    install_pods
  end

  # Build the iOS App
  build_app_lane

  # Upload IPA to TestFlight
  upload_to_testflight_lane

  # Clean up and delete the temporary keychain
  delete_keychain(name: "temp_keychain")

  # Mark deployment as completed for the current commit
  last_commit = last_git_commit
  already_built_flag = ".already_built_#{last_commit[:sha]}"
  File.write(already_built_flag, Time.now.to_s)
end